<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | rodrigolima.github.io]]></title>
  <link href="https://rodrigodlima.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="https://rodrigodlima.github.io/"/>
  <updated>2025-11-27T02:42:25+00:00</updated>
  <id>https://rodrigodlima.github.io/</id>
  <author>
    <name><![CDATA[Rodrigo de Lima Silva]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Removing Unmanaged Files with Puppet]]></title>
    <link href="https://rodrigodlima.github.io/blog/2018/03/01/removing-unmanaged-files-with-puppet/"/>
    <updated>2018-03-01T21:34:54-03:00</updated>
    <id>https://rodrigodlima.github.io/blog/2018/03/01/removing-unmanaged-files-with-puppet</id>
    <content type="html"><![CDATA[<p>Do you know what Puppet is? If you&rsquo;re a Sysadmin or a Dev, I strongly suggest you start learning about it. Puppet is a software configuration management utility. Puppet&rsquo;s development is coordinated by Puppet Labs. Here&rsquo;s the link: <a href="https://puppet.com/">https://puppet.com/</a>.</p>

<p>I won&rsquo;t go deep into the concepts, I&rsquo;ll just share a tip that can be useful in some situations.</p>

<p>You have multiple Apache vhost configuration files managed by Puppet, for example, but you don&rsquo;t want new files to be created manually that aren&rsquo;t orchestrated/managed by Puppet, as this could cause you to lose control of what&rsquo;s being deployed to production.</p>

<p>To solve this, there&rsquo;s an attribute that can help us with this, and it&rsquo;s from the &ldquo;file&rdquo; resource type: <strong>purge</strong></p>

<pre><code>file { '/etc/httpd/confs.d':
    ensure  =&gt; 'directory',
    recurse =&gt; true,
    purge   =&gt; true,
}

file { '/etc/httpd/confs.d/www.conf':
    ensure =&gt; 'present',
    source =&gt; 'puppet://modules/httpd/www.conf',
}
</code></pre>

<p>With the above configuration, Puppet will maintain only the www.conf file in the /etc/httpd/confs.d directory. All manually created files will be removed after the agent communicates with the Puppet server.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automating Commands with Fabric]]></title>
    <link href="https://rodrigodlima.github.io/blog/2017/03/20/automating-commands-with-fabric/"/>
    <updated>2017-03-20T15:43:21-03:00</updated>
    <id>https://rodrigodlima.github.io/blog/2017/03/20/automating-commands-with-fabric</id>
    <content type="html"><![CDATA[<p>This post is just a tip on how to automate some tasks remotely on Linux servers.
Nowadays, automating tasks is extremely necessary in large environments and even in small ones, to avoid work and waste of time.
I usually use Puppet as configuration management for my environment, along with Github for version control of server configurations. Gone are the days when Git was used only by developers, today infrastructure people have used it a lot, following the DevOps concept.</p>

<p>However, Puppet has some limitations, so to speak, for executing remote commands. Sometimes you just want to restart some daemon on your servers. This is not a problem if you have two or three servers, but have you imagined doing this on 200 servers? It will take quite a while until you finish this, right? That&rsquo;s where <a href="http://www.fabfile.org/">Fabric</a> comes in. Fabric is a Python library and command-line utility that uses SSH to execute administrative tasks remotely.</p>

<p>There is good documentation on the <a href="http://www.fabfile.org/">Fabric</a> website, but the objective here is just to demonstrate a practical example of how to use it to execute some tasks remotely.</p>

<p>Before we start, the installation of Fabric can be done with the pip command:</p>

<pre><code># pip install fabric
</code></pre>

<p>You define the tasks you want to execute in a file called &ldquo;fabfile.py&rdquo;. You can define multiple &ldquo;functions&rdquo; in this file, and then you just &ldquo;call&rdquo; the desired function, which makes it much simpler to define multiple tasks without the need to be editing the file for each execution.</p>

<p>Here, an example of the content of the <em>fabfile.py</em> file:</p>

<pre><code>from fabric.api import run, sudo, env, settings,    hide, parallel
from fabric.colors import yellow, green
def host_type():
run('uname -s')

def read_hosts():
"""
Reads hosts from sys.stdin line by line, expecting  one host per line.
"""
import sys
env.hosts = [line.strip() for line in sys.stdin.readlines()]
t)
@parallel

def restart_nginx():
sudo('systemctl restart nginx')
@parallel
</code></pre>

<p>Just explaining a bit about the example above. The host_type function, when called, will execute the <em>uname -s</em> command on all servers and will return the output to the terminal. The second function is a good option if you have a list of hostnames or IPs of your servers in a txt file for example, which it will read line by line from the file and execute the command remotely on the corresponding server. It&rsquo;s important to note, you need to have your public SSH key exported to all servers, so that no password is required at the time of connection.</p>

<p>Now, let&rsquo;s call Fabric to check the hostname of all servers that are listed in the servers.txt file for example:</p>

<pre><code># cat servers.txt |fab read_hosts host_type -P

[server1] Executing task    'host_type'
[server2] Executing task    'host_type'
[server1] run: uname -s
[server2] run: uname -s
[server1] out: Linux
[server1] out:

[server2] out: Linux
[server2] out:


Done.
</code></pre>

<p>The above command executes a <em>cat</em> on the servers.txt file redirecting the output to <em>fab</em> which executes the <em>read_hosts</em> function (which reads each line of the <em>servers.txt</em> file) together with the <em>host_type</em> function. The content of the servers.txt file contains the hostname or IP address of the servers on which Fab will execute the desired function.</p>

<p>The output for each query is displayed on the line with the server hostname and &ldquo;out&rdquo;:</p>

<pre><code>[server1] out: Linux
</code></pre>

<p>Note: The &ldquo;-P&rdquo; parameter in the command means that the command will be executed in parallel, that is, it will execute the command at the same time on all servers.</p>

<p>That&rsquo;s it folks, it&rsquo;s a short article, but it only aims to present this little tool that can make all the difference in your day to day. The documentation is very complete and you will be able to find several examples of how to assemble your tasks&hellip;</p>

<p>;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Changing Runlevel on CentOS7]]></title>
    <link href="https://rodrigodlima.github.io/blog/2017/02/14/changing-runlevel-on-centos7/"/>
    <updated>2017-02-14T16:10:34-02:00</updated>
    <id>https://rodrigodlima.github.io/blog/2017/02/14/changing-runlevel-on-centos7</id>
    <content type="html"><![CDATA[<p>Just a quick tip for those who want to change the Runlevel on CentOS7 or RHEL7.</p>

<p>In previous versions, such as CentOS6, you just had to edit the /etc/inittab file and change the runlevel in the following line:</p>

<pre><code>id:3:initdefault:
</code></pre>

<p>In the example above, the runlevel is set to <b>&ldquo;3&rdquo;</b>. Runlevel 3 means <b>&ldquo;Full multiuser mode&rdquo;</b>, that is, it starts the system normally with network support and mainly in text mode. If you want to change it to start the system with the graphical interface (KDE, Gnome, etc), just change the line above to <b>&ldquo;5&rdquo;</b>.</p>

<p>With the change from Init to Systemd starting from CentOS7 (If you want to know more about this: <a href="http://www.tecmint.com/systemd-replaces-init-in-linux/">Read here</a>, the way the runlevel is changed changes slightly (quite a bit actually ;-)</p>

<h2>Checking current runlevel</h2>

<pre><code>[root@localhost ~] systemctl get-default
multi-user.target
</code></pre>

<p>The multi-user.target is equivalent to runlevel &ldquo;3&rdquo;, that is, text mode.</p>

<h2>Changing the runlevel</h2>

<p>If you want to change the runlevel to graphical mode, or &ldquo;runlevel 5&rdquo; as it was known in previous versions:</p>

<pre><code>[root@localhost ~] systemctl set-default graphical.target
</code></pre>

<p>Just restart the system and you will see that it will start in graphical mode. To check the other Runlevels:</p>

<pre><code>[root@localhost ~] systemctl list-units --type=target
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clearing Java Cache on Linux]]></title>
    <link href="https://rodrigodlima.github.io/blog/2015/04/08/clearing-java-cache-on-linux/"/>
    <updated>2015-04-08T17:54:20-03:00</updated>
    <id>https://rodrigodlima.github.io/blog/2015/04/08/clearing-java-cache-on-linux</id>
    <content type="html"><![CDATA[<p>This is a quick tip for clearing Java cache on Linux.</p>

<p>It&rsquo;s simple. Just open the &ldquo;<strong>Java Control Panel</strong>&rdquo;, to do this, type the command &ldquo;<strong>javaws -viewer</strong>&rdquo; in the terminal.</p>

<pre><code>$ javaws -viewer
</code></pre>

<p>Now just click the Settings button under &ldquo;Temporary Internet Files&rdquo; and delete the cache.</p>

<p>There are other Java configurations that can be performed in the <strong>Java Control Center</strong>, but I won&rsquo;t go into details here.</p>
]]></content>
  </entry>
  
</feed>
